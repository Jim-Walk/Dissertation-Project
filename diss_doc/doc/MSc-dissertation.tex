\documentclass[12pt,a4paper]{report}

\usepackage{epcc}
\usepackage{graphics}

% This example file shows how a thesis can be laid out using Latex. It
% does not use any special local features so should be portable to other
% places.
%
% When producing draft copies of a thesis you may want to print only
% selected pages of the thesis. To do this use the command
%
% dvips -f -p 4 -n 3 myfile.dvi | lpr
%
% where -p 4 means start printing at page 4 (ie the page that will be
% numbered 4, not necessarily the 4th page) and -n 3 means print 3 pages.
% This example will print pages 4, 5 and 6.
%
% If you want to print the thesis and also save paper you can print more
% than one page on each sheet of paper. Use the command
%
% dvips -f myfile.dvi | psnup -2 | lpr
%
% to print 2 pages per sheet. psnup can take values 2, 4, 8, or 9.
%
% To produce a PDF version you can create a PostScript copy first
%
% dvips -f myfile.dvi > myfile.pdf
%
% and then convert it
%
% distill myfile.ps
%
% or you can go straight to PDF
%
% pdflatex myfile
%
% Note that pdflatex expects all included figures to be in PDF too. See
% the includegraphics command below.


% This document contains many cross-references and forward references,
% eg in constructing a table of contents, so Latex may need to be run
% twice to get all the references correct. If you need to run Latex twice
% you may get the warning:
%
% LaTeX Warning: Label(s) may have changed. Rerun to get cross-refSerences right.


% the following 4 lines are the content of the smallmargins.sty file
% but including them explicitly makes this more portable.
%AC%\oddsidemargin=0.1in
%AC%\topmargin=-0.5in
%AC%\textheight=9in
%AC%\textwidth=6.25in

%AC%\parskip 10pt
%AC%\parindent 0in

\begin{document}

%AC%\pagestyle{myheadings}
%AC%\markright{D.~S.~Henty}

%\title{A Latex thesis example}
%\author{D.~S.~Henty}
%\date{\today}

%\maketitle

\pagenumbering{roman}

\title{High Performance Rust}
\author{Jim Walker}
\date{\today}

\makeEPCCtitle

\thispagestyle{empty}

\vspace{12cm}

\begin{center}

\large{MSc in High Performance Computing}

\large{The University of Edinburgh}

\large{Year of Presentation: 2019}

\end{center}

\newpage

\begin{abstract}
This dissertation examines the suitabilty of the Rust programming language, to High Performance Computing (HPC). This examination is made through porting three HPC mini apps to Rust from typical HPC languages and comparing the perfomance of the Rust and the original implementation. We also investigate the readability of Rust's higher level programming syntax for HPC programmers through the use of a questionnaire.
\end{abstract}

\pagenumbering{roman}

\tableofcontents
\listoftables
\listoffigures

\begin{titlepage}
\vspace*{2in}
% an acknowledgements section is completely optional but if you decide
% not to include it you should still include an empty {titlepage}
% environment as this initialises things like section and page numbering.
\section*{Acknowledgements}

This template is a slightly modified version of the one developed by
Prof. Charles Duncan for MSc students in the Dept. of Meteorology. His
acknowledgement follows:

{\em This template has been produced with help from many former students who
have shown different ways of doing things. Please make suggestions for
further improvements.}

\end{titlepage}

\pagenumbering{arabic}

\input{sections/intro.tex}

\chapter{Methodology}
\section{Mini-Apps}
Mini-apps are a well established method of assessing new programming languages or techniques within HPC~\cite{Mallinson:2014, Slaughter:2015, martineau2017arch}. A mini-app is a small program which reproduces some functionality of a common HPC use case. Often, the program will be implemented using one particular technology, and then ported to another technology. The performance of the two mini-apps will then be benchmarked, to see which technology is better suited to the particular problem represented by that mini-app.
\subsection{Selection}
So that a bredth of usage scenarios were examined, three mini-apps were selected based on their conformity to the following set of criteria.
\begin{itemize}
  \item \textbf{The program's kernel (i.e. the part of the program responsible for more than two thirds processing time) should not be more than 1500 lines.} To ensure that I fully implemented three ports of exisiting mini-apps, it was necessary to limit the size of the mini-apps that could be considered. This was an unfortunately necessary decision to make. Whilst it reduced the field of possible mini-apps, an analysis of the rejected mini-apps found that many of them devoted lots of code to subtle computational variations, which were of more importance to a particular rareified domain, rather than presenting a novel approach to parallelism. (i could cite some benchmarks here like bookleaf or something)

  \item \textbf{The program must use shared memory parallelism and target the CPU.} Rust's (supposed) zero cost memory safety features are its unique feature. The best way to test the true cost of Rust's memory safety features would be through shared memory parallelism, where a poor implementation of memory management will make itself evident through poor performance.

  \item \textbf{The program run time should reasonably decrease as the number of threads increases, at least until the number of threads reaches 32.} It is important that any mini-app considered is capable of scaling to the high core counts normally seen in HPC.

  \item \textbf{The program should perform at least two mathematical operations on data greater than the CPU's L3 Cache} so that we can be sure that the mini-app is representative of working on large data sets.

  \item \textbf{The program must be written in C or C++.} This restriction allows us to choose work which is more representative of HPC programs that actually run on HPC systems, rather than python programs which call out to pre-compiled libraries. C and C++ also use array indexing and layout conventions simillar to Rust, which will make porting programs from them easier.

  \item \textbf{The program must use OMP.} This is the defacto standard for shared memory parallelism in HPC. Use of a library to do the parallel processing also further standardises the candidate programs.
\end{itemize}

\subsection{Implementation}
\subsubsection{Babel Stream}

\section{Questionnaire}


\chapter{Babel Stream}
\section{Development}
\section{Comparison}


\chapter{Sparse Matrix Multiplication}
\section{Development}
\section{Comparison}

\chapter{K-means}
\section{Development}
\section{Comparison}

\chapter{Rust's usability}
Here are some questionnaire results.



% in practice you would probably keep this in a separate file and use
% the \include{filename} command to insert it here.



\chapter{Conclusions}

This is the place to put your conclusions about your work. You can
split it into different sections if appropriate. You may want to include
a section of future work which could be carried out to continue your
research.

\appendix
% the appendix command just changes heading styles for appendices.

\chapter{Stuff which is too detailed}

Appendices should contain all the material which is considered too
detailed to be included in the main bod but which is, nevertheless,
important enough to be included in the thesis.

\chapter{Stuff which no-one will read}

Some people include in their thesis a lot of detail, particularly
computer code, which no-one will ever read. You should be careful that
anything like this you include should contain some element of uniqueness
which justifies its inclusion.

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

\chapter{Conclusions}
Through my implementation of Rust kernels, I found that learning Rust was not profoundly difficult. Whilst I did struggle sometimes, most profoundly with parallel initialisation, it is arguable that porting C-style programs to Rust has a steeper learning curve than writing Rust implementations from scratch. The former will not be suited to the idioms of the Rust, whereas the latter will be, and will be more likely to have documented techniques. However, it is  worth noting that none of these kernels had a particularly complex structure, and that I therefore have only a basic grasp of the Rust language. Learning more complicated concepts of Rust, like smart pointers or unsafe Rust may present more of a challenge.

Comparing the performance of the kernel implementations yielded interesting results. In particular, it is noteworthy Rust's performance was often so close to the C or C++ implementation, that I began comparing OpenMP with Rayon, not C and C++ with Rust. This finding implies that Rust is a suitable candidate for HPC, although it may need better threading APIs to become a truly competitive solution.

The data from the questionnaire showed that past programming language experience does little to predict how easily someone will be able to understand Rust. As five out of eleven participants got more than half the questions right, it is also difficult to confidently state how easy Rust is to understand. 

Lastly there is one important aspect of Rust's suitability which lay outside the scope of this dissertation, but is nonetheless important. The acceptance of any new technology within a discipline also relies upon sociological aspects, such as a groups desire or ability to change. Rust could be a faster language than C and C++, which prevents memory errors and is fast to write, but if the HPC community does not want to change, it will not change.

\section{Further Work}\label{sec:furth}
Porting a large, complex mini-app to Rust would certainly provide a more detailed experience of translating C or C++ techniques to Rust. Such a process could thoroughly inspect how well sharing behaviour between objects, like with C++ inheritance through classes maps to Rust's composition through traits. Porting a complex mini-app could potentially expose the programmer to more advanced Rust concepts, and provide better insight into how an actual Rust HPC application would be structured.

It would be interesting to make another comparison between C and Rust implementations of Babel Stream, but to implement a work stealing schedule for OpenMP\@. Such a comparison could demonstrate the effect Rayon's scheduling algorithm on Babel Stream, and provide a fairer test between the two implementations. This process could also be repeated with the K-means clustering kernel. 

Expanding on and clarifying the issues raised by the questionnaire would require greater study. In particular, more participants would be needed to provide better data, and more questions could be asked of them. An interesting experiment could be to ask a one selection of masters students to complete an assignment in Rust, and the other to complete it in C or C++, where both groups have a low level of understanding in both languages, and similar academic ability. This experiment would provide more conclusive data on how hard Rust is to learn.

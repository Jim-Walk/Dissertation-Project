\chapter{Introduction}
In the field of high performance computing (HPC), most programs have been written one of three programming languages for the last two decades. Those programming languages are Fortran, C, and C++. Although these are well established programming languages, they are not without their problems. Most notably, they lack memory safety, which can lead to programs crashing or returning incorrect results. I discuss this in more detail in the background Section~\ref{sec:c}. Rust, on the other hand, has a design which prioritises memory safety, allegedly without negatevly affecting its performance. 
Its designers say that the language provides `High-level ergonomics and low-level control' to help `you write faster, more reliable software'~\cite{RustBook}.

The suitability of Rust for HPC is examined through the lens of three research questions. Firstly, how easy is it to learn to program in Rust? For a programming language to become widely adopted it needs a low barrier to entry. Rust's memory safety system comes at the cost of more compulsory syntax, which I go on to explain in Section~\ref{sec:rust}. I investigate the difficulty of learning Rust by porting some small programs, or {\em kernels}, to Rust from C and C++. I discuss this experience in Section~\ref{sec:impl}.

Secondly, how does the performance of Rust compare to established high performance languages like C and C++?
The speed at which a program runs is extremely important in HPC, as they often run on extremely large data sets which can take a long time to complete. Marginal performance gains of 5\% for HPC programs can therefore mean programs complete an hour or two earlier.
The high priority of speed in HPC programming is demonstrated through Java, a programming language with a garbage collecter and higher degree of memory safety than C and C++, has not become widely used in HPC\@. I will answer this question through comparing the performance of my implementations of the kernels in Rust, and their original implementations. I present my results for this in Section~\ref{sec:res-babel},~\ref{sec:res-sparse} and~\ref{sec:res-kmeans}.

Lastly, easy is it to understand Rust? Whilst this question is of a similar nature to the first question, it focuses more on how easy it is to read Rust, not how easy it is to write it. This distinction is important, because often old code must be maintained, or especially in HPC, configured to run in certain ways for certain datasets. These things are not possible if the programmer does not know what the program is doing. I investigate this question through the use of a questionaire, which I discuss the design of in Section~\ref{sec:meth-q}, and the results of it in Section~\ref{sec:res-q}.

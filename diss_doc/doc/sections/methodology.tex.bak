\chapter{Methodology}
\section{Mini-Apps}
Mini-apps are a well established method of assessing new programming languages or techniques within HPC~\cite{Mallinson:2014, Slaughter:2015, martineau2017arch}. A mini-app is a small program which reproduces some functionality of a common HPC use case. Often, the program will be implemented using one particular technology, and then ported to another technology. The performance of the two mini-apps will then be benchmarked, to see which technology is better suited to the particular problem represented by that mini-app. Such an approach gives quantitive data which provides a strong indication for the performance of a technology in a full implementation of an application. This dissertation will follow a similar approach of evaluating a program through the performance of a mini-app.

I will also evaluate the ease with which I am able to port a mini-app into Rust, alongside other notes on my general experience of programming in Rust.
\subsection{Selection}
So that a bredth of usage scenarios were examined, three mini-apps were selected based on their conformity to the following set of criteria.
\begin{itemize}
  \item \textbf{The program's kernel (i.e. the part of the program responsible for more than two thirds processing time) should not be more than 1500 lines.} To ensure that I fully implemented three ports of exisiting mini-apps, it was necessary to limit the size of the mini-apps that could be considered. This was an unfortunately necessary decision to make. Whilst it reduced the field of possible mini-apps, an analysis of the rejected mini-apps found that many of them devoted lots of code to subtle computational variations, which were of more importance to a particular rareified domain, rather than presenting a novel approach to parallelism. (i could cite some benchmarks here like bookleaf or something)

  \item \textbf{The program must use shared memory parallelism and target the CPU.} Rust's (supposed) zero cost memory safety features are its unique feature. The best way to test the true cost of Rust's memory safety features would be through shared memory parallelism, where a poor implementation of memory management will make itself evident through poor performance.

  \item \textbf{The program run time should reasonably decrease as the number of threads increases, at least until the number of threads reaches 32.} It is important that any mini-app considered is capable of scaling to the high core counts normally seen in HPC.

  \item \textbf{The program should perform at least two mathematical operations on data greater than the CPU's L3 Cache} so that we can be sure that the mini-app is representative of working on large data sets.

  \item \textbf{The program must be written in C or C++.} This restriction allows us to choose work which is more representative of HPC programs that actually run on HPC systems, rather than python programs which call out to pre-compiled libraries. C and C++ also use array indexing and layout conventions simillar to Rust, which will make porting programs from them easier.

  \item \textbf{The program must use OMP.} This is the defacto standard for shared memory parallelism in HPC. Use of a library to do the parallel processing also further standardises the candidate programs.
\end{itemize}

\subsection{Implementation}
\subsubsection{Babel Stream}

\section{Questionnaire}

\chapter{Background}
\section{High Performance Computing}
High Performance Computing (HPC) is the name commonly given to computation which is performed on supercomputers. 
Supercomputers generally have more and faster cores than personal computers. Generally, supercomputers are used for highly numerical scientific programs. The high core count on supercomputers leads to these programs using parallel computing techniques, which share the computation between the processing cores.

The Illiac IV is generally considered to be the first supercomputer with a modern design, in that it was, for its time, massively parallel, with 64 processing cores. It's 
This division of labour allows bigger problems to be solved more quickly.

\begin{itemize}
    \item What was HPC?
    \item What is HPC?
    \item What are the challenges for HPC?
\end{itemize}

Shared memory parallelism.
\subsection{Development Environment?}

\section{C/C++}
The C programming language was developed in the early 1970s, as a `system implementation language'~\cite{Ritchie:1993}. Its first purpose was to program operating systems and the utilities which were fundamental to their use, like \texttt{cat} and \texttt{rm}. Since that point, the C programming language has always been associated with low level computing. In this case, low level computing means computing which is able to be compiled to very efficient machine code, and gives the programmer fine grained memory management.
Today, the Linux kernel, which provides the foundation for the operating systems used on the vast majority of the world's supercomputers, is 96\% written in C~\cite{LinuxKernel}. X years later, the C++ language was invented as an extension to C. It also focused on system programming~\cite{CplusEssence}.

\begin{itemize}
    \item Brief history of C and C++
    \item How are they used today (libraries and stuff)
    \item Problems of C, how C++ tries and fails to fix them
    \item Compiler choices and why
    \item my level of knowledge
\end{itemize}
\subsection{OpenMP}
\begin{itemize}
    \item Brief history of  OpenMP
    \item Some indication of OpenMP as a standard
    \item Example OpenMP program, and evaluation
    \item my level of knowledge
\end{itemize}

\section{Rust}
Who developed it? Why?

mention borrow checker. Which rustc version am I using? rustc 1.34.2. Safe vs unsafe rust
What's a macro?
How do I get support for Rust?

Cargo, and Cargo.toml
 
example program, which does a memory safe thing compared to previous C example.
\subsection{Rayon}
Talk about the underlying nature of Rayon and its random scheduling. Not official library for easy parallelism but it's used a lot in the book.
What's an iterator?
\section{Kernels}
By Kernels I mean blah blah. I will use Kernels in a similar way to how Mini-apps have been used in research in the past.

Mini-apps are a well established method of assessing new programming languages or techniques within HPC~\cite{Mallinson:2014, Slaughter:2015, martineau2017arch}. A mini-app is a small program which reproduces some functionality of a common HPC use case. Often, the program will be implemented using one particular technology, and then ported to another technology. The performance of the two mini-apps will then be tested, to see which technology is better suited to the particular problem represented by that mini-app. Such an approach gives quantitative data which provides a strong indication for the performance of a technology in a full implementation of an application. I am going to use Kernels rather than mini-apps because more breadth and less time, more use cases, better indication

This dissertation will follow a similar approach of evaluating a program through the performance of a kernel, using the test data to find any weaknesses in the Rust or original implementation.

I will also evaluate the ease with which I am able to port a kernel into Rust. These observations will provide insight into what it is like to program in Rust, if its strict memory model and functional idioms help or hinder translation from the imperative languages which the ported programs are written in. This qualitative, partly experiential information will hopefully provide an insight into the actual practicalities of programming in Rust. For Rust to be fully accepted by the HPC community, it is necessary that the program fulfils the functional requirements of speed and scaling, alongside non functional requirements, of usability and user experience. The first factor provides a reason for using Rust programs in HPC, the second provides an impetus for learning how to write those programs


\todo{Why use reference implementations and not write my own?}
\section{Roofline} stuff makes sense here.
